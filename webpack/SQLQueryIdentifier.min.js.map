{"version":3,"sources":["webpack://SQLQueryIdentifier/webpack/universalModuleDefinition","webpack://SQLQueryIdentifier/./src/tokenizer.js","webpack://SQLQueryIdentifier/./src/parser.js","webpack://SQLQueryIdentifier/./src/index.js","webpack://SQLQueryIdentifier/webpack/bootstrap","webpack://SQLQueryIdentifier/webpack/startup","webpack://SQLQueryIdentifier/webpack/runtime/define property getters","webpack://SQLQueryIdentifier/webpack/runtime/hasOwnProperty shorthand","webpack://SQLQueryIdentifier/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","KEYWORDS","INDIVIDUALS","scanToken","state","ch","read","isWhitespace","nextChar","unread","value","input","slice","start","position","type","end","length","scanWhitespace","isComment","isCommentInline","scanCommentInline","isCommentBlock","prevChar","scanCommentBlock","isString","scanString","match","isDollarQuotedString","label","i","scanDollarQuotedString","isLetter","word","includes","toUpperCase","skipWord","scanWord","individual","resolveIndividualTokenType","scanIndividualCharacter","skipChar","EXECUTION_TYPES","SELECT","INSERT","DELETE","UPDATE","CREATE_DATABASE","CREATE_TABLE","CREATE_TRIGGER","CREATE_FUNCTION","DROP_DATABASE","DROP_TABLE","DROP_TRIGGER","DROP_FUNCTION","TRUNCATE","UNKNOWN","statementsWithEnds","blockOpeners","generic","psql","mysql","mssql","sqlite","parse","statementParser","isStrict","dialect","topLevelState","initState","topLevelStatement","body","tokens","prevState","ignoreOutsideBlankTokens","tokenState","token","push","createStatementParserByToken","addToken","statement","getStatement","endStatement","options","steps","preCanGoToNext","validation","acceptTokens","add","postCanGoToNext","stateMachineStatementParser","requireBefore","createCreateStatementParser","createDropStatementParser","createInsertStatementParser","createUpdateStatementParser","createDeleteStatementParser","createTruncateStatementParser","createUnknownStatementParser","Error","prevToken","prevPrevToken","currentStepIndex","openBlocks","setPrevToken","canEnd","definer","step","currentStep","requireds","join","filter","accept","isValidType","isValidValue","isValidToken","expecteds","map","executionType","allowedDialects","identify","query","strict","result","text","substring","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"SQLQueryIdentifier.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(self, function() {\nreturn ","/**\n * Tokenizer\n */\n\n/* eslint no-param-reassign: 0 */\nconst KEYWORDS = [\n  'SELECT',\n  'INSERT',\n  'DELETE',\n  'UPDATE',\n  'CREATE',\n  'DROP',\n  'TABLE',\n  'TRIGGER',\n  'FUNCTION',\n  'DATABASE',\n  'TRUNCATE',\n];\n\nconst INDIVIDUALS = {\n  ';': 'semicolon',\n};\n\nexport function scanToken (state) {\n  const ch = read(state);\n\n  if (isWhitespace(ch)) {\n    return scanWhitespace(state);\n  }\n\n  if (isCommentInline(ch, state)) {\n    return scanCommentInline(state);\n  }\n\n  if (isCommentBlock(ch, state)) {\n    return scanCommentBlock(state);\n  }\n\n  if (isString(ch)) {\n    return scanString(state);\n  }\n\n  if (isDollarQuotedString(state)) {\n    return scanDollarQuotedString(state);\n  }\n\n  if (isLetter(ch)) {\n    return scanWord(state);\n  }\n\n  const individual = scanIndividualCharacter(state);\n  if (individual) {\n    return individual;\n  }\n\n  return skipChar(state);\n}\n\nfunction read (state) {\n  if (state.position === state.input.length - 1) {\n    return null;\n  }\n\n  state.position++;\n  return state.input[state.position];\n}\n\nfunction unread (state) {\n  if (state.position === state.start) {\n    return;\n  }\n\n  state.position--;\n}\n\nfunction isKeyword (word) {\n  return KEYWORDS.includes(word.toUpperCase());\n}\n\nfunction resolveIndividualTokenType (ch) {\n  return INDIVIDUALS[ch];\n}\n\nfunction scanWhitespace (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isWhitespace(nextChar));\n\n  if (nextChar !== null && !isWhitespace(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'whitespace',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanCommentInline (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\n' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\n') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-inline',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanDollarQuotedString (state) {\n  const label = state.input.slice(state.start).match(/^(\\$[a-zA-Z0-9_]*\\$)/)[1];\n  for (let i = 0; i < (label.length - 1); i++) {\n    read(state);\n  }\n\n  let nextChar;\n  while (state.input.slice(state.position, state.position + label.length) !== label && nextChar !== null) {\n    do {\n      nextChar = read(state);\n    } while (nextChar !== '$' && nextChar !== null);\n\n    if (nextChar !== '$' && nextChar !== null) {\n      unread(state);\n    }\n  }\n\n  for (let i = 0; i < (label.length - 1); i++) {\n    read(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'string',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanString (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\'' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\'') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'string',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanCommentBlock (state) {\n  let nextChar;\n  let prevChar;\n\n  do {\n    prevChar = nextChar;\n    nextChar = read(state);\n  } while ((prevChar + nextChar !== '*/') && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '/') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-block',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanWord (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isLetter(nextChar));\n\n  if (nextChar !== null && !isLetter(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  if (!isKeyword(value)) {\n    return skipWord(state, value);\n  }\n\n  return {\n    type: 'keyword',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanIndividualCharacter (state) {\n  const value = state.input.slice(state.start, state.position + 1);\n  const type = resolveIndividualTokenType(value);\n  if (!type) {\n    return null;\n  }\n\n  return {\n    type,\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction skipChar (state) {\n  return {\n    type: 'unknown',\n    value: state.input.slice(state.start, state.position + 1),\n    start: state.start,\n    end: state.start,\n  };\n}\n\nfunction skipWord (state, value) {\n  return {\n    type: 'unknown',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction isWhitespace (ch) {\n  return ch === ' ' || ch === '\\t' || ch === '\\n';\n}\n\nfunction isString (ch) {\n  return ch === \"'\";\n}\n\nfunction isDollarQuotedString (state) {\n  return state.input.slice(state.start).match(/^\\$[\\w]*\\$/);\n}\n\nfunction isCommentInline (ch, state) {\n  let isComment = ch === '-';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '-';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\nfunction isCommentBlock (ch, state) {\n  let isComment = ch === '/';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '*';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\nfunction isLetter (ch) {\n  return (ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z')\n      || ch === '_';\n}\n","import { scanToken } from './tokenizer';\n\n/**\n * Execution types allow to know what is the query behavior\n *  - LISTING: is when the query list the data\n *  - MODIFICATION: is when the query modificate the database somehow (structure or data)\n *  - INFORMATION: is show some data information such as a profile data\n *  - UNKNOWN\n */\nconst EXECUTION_TYPES = {\n  SELECT: 'LISTING',\n  INSERT: 'MODIFICATION',\n  DELETE: 'MODIFICATION',\n  UPDATE: 'MODIFICATION',\n  CREATE_DATABASE: 'MODIFICATION',\n  CREATE_TABLE: 'MODIFICATION',\n  CREATE_TRIGGER: 'MODIFICATION',\n  CREATE_FUNCTION: 'MODIFICATION',\n  DROP_DATABASE: 'MODIFICATION',\n  DROP_TABLE: 'MODIFICATION',\n  DROP_TRIGGER: 'MODIFICATION',\n  DROP_FUNCTION: 'MODIFICATION',\n  TRUNCATE: 'MODIFICATION',\n  UNKNOWN: 'UNKNOWN',\n};\n\nconst statementsWithEnds = ['CREATE_TRIGGER', 'CREATE_FUNCTION'];\nconst blockOpeners = {\n  generic: ['BEGIN', 'CASE'],\n  psql: ['BEGIN', 'CASE', 'LOOP', 'IF'],\n  mysql: ['BEGIN', 'CASE', 'LOOP', 'IF'],\n  mssql: ['BEGIN', 'CASE'],\n  sqlite: ['BEGIN', 'CASE'],\n};\n\n/**\n * Parser\n */\nexport function parse (input, isStrict = true, dialect = 'generic') {\n  const topLevelState = initState({ input });\n  const topLevelStatement = {\n    type: 'QUERY',\n    start: 0,\n    end: input.length - 1,\n    body: [],\n    tokens: [],\n  };\n\n  let prevState = topLevelState;\n  let statementParser;\n\n  const ignoreOutsideBlankTokens = [\n    'whitespace',\n    'comment-inline',\n    'comment-block',\n  ];\n\n  while (prevState.position < topLevelState.end) {\n    const tokenState = initState({ prevState });\n    const token = scanToken(tokenState);\n\n    if (!statementParser) {\n      // ignore blank tokens that are not in a statement\n      if (ignoreOutsideBlankTokens.includes(token.type)) {\n        topLevelStatement.tokens.push(token);\n        prevState = tokenState;\n        continue;\n      }\n\n      statementParser = createStatementParserByToken(token, { isStrict, dialect });\n    }\n\n    statementParser.addToken(token);\n    topLevelStatement.tokens.push(token);\n    prevState = tokenState;\n\n    const statement = statementParser.getStatement();\n    if (statement.endStatement) {\n      statement.end = token.end;\n      topLevelStatement.body.push(statement);\n      statementParser = null;\n    }\n  }\n\n  // last statement without ending key\n  if (statementParser) {\n    const statement = statementParser.getStatement();\n    if (!statement.endStatement) {\n      statement.end = topLevelStatement.end;\n      topLevelStatement.body.push(statement);\n    }\n  }\n\n  return topLevelStatement;\n}\n\nfunction initState ({ input, prevState }) {\n  if (prevState) {\n    return {\n      input: prevState.input,\n      position: prevState.position,\n      start: prevState.position + 1,\n      end: prevState.input.length - 1,\n      body: [],\n    };\n  }\n\n  return {\n    input,\n    position: -1,\n    start: 0,\n    end: input.length - 1,\n    body: [],\n  };\n}\n\nfunction createStatementParserByToken (token, options) {\n  if (token.type === 'keyword') {\n    switch (token.value.toUpperCase()) {\n      case 'SELECT': return createSelectStatementParser(options);\n      case 'CREATE': return createCreateStatementParser(options);\n      case 'DROP': return createDropStatementParser(options);\n      case 'INSERT': return createInsertStatementParser(options);\n      case 'UPDATE': return createUpdateStatementParser(options);\n      case 'DELETE': return createDeleteStatementParser(options);\n      case 'TRUNCATE': return createTruncateStatementParser(options);\n      default: break;\n    }\n  }\n\n  if (!options.isStrict && token.type === 'unknown') {\n    return createUnknownStatementParser(options.isStrict);\n  }\n\n  throw new Error(`Invalid statement parser \"${token.value}\"`);\n}\n\nfunction createSelectStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Select\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'SELECT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'SELECT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createInsertStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Insert\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'INSERT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'INSERT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createUpdateStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Update\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'UPDATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'UPDATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createDeleteStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Delete\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DELETE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'DELETE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createCreateStatementParser ({ isStrict, dialect }) {\n  const statement = {};\n\n  const steps = [\n    // Create\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'CREATE' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n          { type: 'keyword', value: 'TRIGGER' },\n          { type: 'keyword', value: 'FUNCTION' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `CREATE_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict, dialect });\n}\n\nfunction createDropStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Drop\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DROP' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n          { type: 'keyword', value: 'TRIGGER' },\n          { type: 'keyword', value: 'FUNCTION' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `DROP_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createTruncateStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'TRUNCATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'TRUNCATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createUnknownStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      add: (token) => {\n        statement.type = 'UNKNOWN';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction stateMachineStatementParser (statement, steps, { isStrict, dialect = 'generic' }) {\n  let currentStepIndex = 0;\n  let prevToken;\n  let prevPrevToken;\n\n  let openBlocks = 0;\n\n  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n  const isValidToken = (step, token) => {\n    if (!step.validation) {\n      return true;\n    }\n\n    return step\n      .validation\n      .acceptTokens.filter((accept) => {\n        const isValidType = token.type === accept.type;\n        const isValidValue = (\n          !accept.value\n          || token.value.toUpperCase() === accept.value\n        );\n\n        return isValidType && isValidValue;\n      }).length > 0;\n  };\n\n  const hasRequiredBefore = (step) => {\n    return (\n      !step.requireBefore\n      || step.requireBefore.includes(prevToken.type)\n    );\n  };\n\n  const setPrevToken = (token) => {\n    prevPrevToken = prevToken;\n    prevToken = token;\n  };\n\n  return {\n    getStatement () {\n      return statement;\n    },\n\n    addToken (token) {\n      /* eslint no-param-reassign: 0 */\n      if (statement.endStatement) {\n        throw new Error('This statement has already got to the end.');\n      }\n\n      if (\n        token.type === 'semicolon'\n        && (\n          !statementsWithEnds.includes(statement.type)\n          || (openBlocks === 0 && statement.canEnd)\n        )\n      ) {\n        statement.endStatement = ';';\n        return;\n      }\n\n      if (token.value.toUpperCase() === 'END') {\n        openBlocks--;\n        if (openBlocks === 0) {\n          statement.canEnd = true;\n        }\n        setPrevToken(token);\n        return;\n      }\n\n      if (token.type === 'whitespace') {\n        setPrevToken(token);\n        return;\n      }\n\n      // Postgres allows for optional \"OR REPLACE\" between \"CREATE\" and \"FUNCTION\", so we need to ignore\n      // these tokens.\n      if (dialect === 'psql' && ['OR', 'REPLACE'].includes(token.value.toUpperCase())) {\n        return;\n      }\n\n      if (token.type === 'keyword' && blockOpeners[dialect].includes(token.value) && prevPrevToken.value !== 'END') {\n        openBlocks++;\n        setPrevToken(token);\n        return;\n      }\n\n      // MySQL allows for setting a definer for a function which specifies who the function is executed as.\n      // This clause is optional, and is defined between the \"CREATE\" and \"FUNCTION\" keywords for the statement.\n      if (dialect === 'mysql' && token.value.toUpperCase() === 'DEFINER') {\n        statement.definer = 0;\n        setPrevToken(token);\n        return;\n      }\n\n      if (statement.definer === 0 && token.value === '=') {\n        statement.definer++;\n        setPrevToken(token);\n        return;\n      }\n\n      if (statement.definer > 0) {\n        if (statement.definer === 1 && prevToken.type === 'whitespace') {\n          statement.definer++;\n          setPrevToken(token);\n          return;\n        }\n\n        if (statement.definer > 1 && prevToken.type !== 'whitespace') {\n          setPrevToken(token);\n          return;\n        }\n\n        statement.definer = false;\n      }\n\n      if (statement.type) {\n        // statement has already been identified\n        // just wait until end of the statement\n        return;\n      }\n\n      let currentStep = steps[currentStepIndex];\n      if (currentStep.preCanGoToNext(token)) {\n        currentStepIndex++;\n        currentStep = steps[currentStepIndex];\n      }\n\n      if (!hasRequiredBefore(currentStep)) {\n        const requireds = currentStep.requireBefore.join(' or ');\n        throw new Error(`Expected any of these tokens ${requireds} before \"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      if (!isValidToken(currentStep, token) && isStrict) {\n        const expecteds = currentStep\n          .validation\n          .acceptTokens\n          .map((accept) => `(type=\"${accept.type}\" value=\"${accept.value}\")`)\n          .join(' or ');\n        throw new Error(`Expected any of these tokens ${expecteds} instead of type=\"${token.type}\" value=\"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      currentStep.add(token);\n\n      statement.executionType = EXECUTION_TYPES[statement.type] || 'UNKNOWN';\n\n      if (currentStep.postCanGoToNext(token)) {\n        currentStepIndex++;\n      }\n\n      setPrevToken(token);\n    },\n  };\n}\n","import { parse } from './parser';\n\nconst allowedDialects = ['mssql', 'sqlite', 'mysql', 'psql', 'generic'];\n/**\n * Identifier\n */\nexport function identify (query, options = {}) {\n  const isStrict = typeof options.strict === 'undefined' ? true : options.strict;\n  const dialect = typeof options.dialect === 'undefined' ? 'generic' : options.dialect;\n\n  if (!allowedDialects.includes(dialect)) {\n    throw new Error(`Unknown dialect. Allowed values: ${allowedDialects.join(',')}`);\n  }\n\n  const result = parse(query, isStrict, dialect);\n\n  return result.body.map((statement) => ({\n    start: statement.start,\n    end: statement.end,\n    text: query.substring(statement.start, statement.end + 1),\n    type: statement.type,\n    executionType: statement.executionType,\n  }));\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(468);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}