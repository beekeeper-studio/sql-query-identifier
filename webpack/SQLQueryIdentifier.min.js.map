{"version":3,"sources":["webpack://SQLQueryIdentifier/webpack/universalModuleDefinition","webpack://SQLQueryIdentifier/./src/tokenizer.js","webpack://SQLQueryIdentifier/./src/parser.js","webpack://SQLQueryIdentifier/./src/index.js","webpack://SQLQueryIdentifier/webpack/bootstrap","webpack://SQLQueryIdentifier/webpack/startup","webpack://SQLQueryIdentifier/webpack/runtime/define property getters","webpack://SQLQueryIdentifier/webpack/runtime/hasOwnProperty shorthand","webpack://SQLQueryIdentifier/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","KEYWORDS","INDIVIDUALS","scanToken","state","ch","read","isWhitespace","nextChar","unread","value","input","slice","start","position","type","end","length","scanWhitespace","isComment","isCommentInline","scanCommentInline","isCommentBlock","prevChar","scanCommentBlock","isString","scanString","isLetter","word","includes","toUpperCase","skipWord","scanWord","individual","resolveIndividualTokenType","scanIndividualCharacter","skipChar","EXECUTION_TYPES","SELECT","INSERT","DELETE","UPDATE","CREATE_DATABASE","CREATE_TABLE","CREATE_TRIGGER","DROP_DATABASE","DROP_TABLE","TRUNCATE","UNKNOWN","dialectsWithEnds","parse","statementParser","isStrict","dialect","topLevelState","initState","topLevelStatement","body","tokens","prevState","ignoreOutsideBlankTokens","tokenState","token","push","createStatementParserByToken","addToken","statement","getStatement","endStatement","options","steps","preCanGoToNext","validation","acceptTokens","add","postCanGoToNext","stateMachineStatementParser","requireBefore","createCreateStatementParser","createDropStatementParser","createInsertStatementParser","createUpdateStatementParser","createDeleteStatementParser","createTruncateStatementParser","createUnknownStatementParser","Error","prevToken","currentStepIndex","canEnd","step","currentStep","requireds","join","filter","accept","isValidType","isValidValue","isValidToken","expecteds","map","executionType","allowedDialects","identify","query","strict","result","text","substring","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"SQLQueryIdentifier.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(self, function() {\nreturn ","/**\n * Tokenizer\n */\n\n/* eslint no-param-reassign: 0 */\nconst KEYWORDS = [\n  'SELECT',\n  'INSERT',\n  'DELETE',\n  'UPDATE',\n  'CREATE',\n  'DROP',\n  'TABLE',\n  'TRIGGER',\n  'DATABASE',\n  'TRUNCATE',\n];\n\nconst INDIVIDUALS = {\n  ';': 'semicolon',\n};\n\nexport function scanToken (state) {\n  const ch = read(state);\n\n  if (isWhitespace(ch)) {\n    return scanWhitespace(state);\n  }\n\n  if (isCommentInline(ch, state)) {\n    return scanCommentInline(state);\n  }\n\n  if (isCommentBlock(ch, state)) {\n    return scanCommentBlock(state);\n  }\n\n  if (isString(ch, state)) {\n    return scanString(state);\n  }\n\n  if (isLetter(ch)) {\n    return scanWord(state);\n  }\n\n  const individual = scanIndividualCharacter(state);\n  if (individual) {\n    return individual;\n  }\n\n  return skipChar(state);\n}\n\nfunction read (state) {\n  if (state.position === state.input.length - 1) {\n    return null;\n  }\n\n  state.position++;\n  return state.input[state.position];\n}\n\nfunction unread (state) {\n  if (state.position === state.start) {\n    return;\n  }\n\n  state.position--;\n}\n\nfunction isKeyword (word) {\n  return KEYWORDS.includes(word.toUpperCase());\n}\n\nfunction resolveIndividualTokenType (ch) {\n  return INDIVIDUALS[ch];\n}\n\nfunction scanWhitespace (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isWhitespace(nextChar));\n\n  if (nextChar !== null && !isWhitespace(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'whitespace',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanCommentInline (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\n' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\n') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-inline',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanString (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\'' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\'') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'string',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanCommentBlock (state) {\n  let nextChar;\n  let prevChar;\n\n  do {\n    prevChar = nextChar;\n    nextChar = read(state);\n  } while ((prevChar + nextChar !== '*/') && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '/') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-block',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanWord (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isLetter(nextChar));\n\n  if (nextChar !== null && !isLetter(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  if (!isKeyword(value)) {\n    return skipWord(state, value);\n  }\n\n  return {\n    type: 'keyword',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction scanIndividualCharacter (state) {\n  const value = state.input.slice(state.start, state.position + 1);\n  const type = resolveIndividualTokenType(value);\n  if (!type) {\n    return null;\n  }\n\n  return {\n    type,\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction skipChar (state) {\n  return {\n    type: 'unknown',\n    value: state.input.slice(state.start, state.position + 1),\n    start: state.start,\n    end: state.start,\n  };\n}\n\nfunction skipWord (state, value) {\n  return {\n    type: 'unknown',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction isWhitespace (ch) {\n  return ch === ' ' || ch === '\\t' || ch === '\\n';\n}\n\nfunction isString (ch) {\n  return ch === '\\'';\n}\n\nfunction isCommentInline (ch, state) {\n  let isComment = ch === '-';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '-';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\nfunction isCommentBlock (ch, state) {\n  let isComment = ch === '/';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '*';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\nfunction isLetter (ch) {\n  return (ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z');\n}\n","import { scanToken } from './tokenizer';\n\n/**\n * Execution types allow to know what is the query behavior\n *  - LISTING: is when the query list the data\n *  - MODIFICATION: is when the query modificate the database somehow (structure or data)\n *  - INFORMATION: is show some data information such as a profile data\n *  - UNKNOWN\n */\nconst EXECUTION_TYPES = {\n  SELECT: 'LISTING',\n  INSERT: 'MODIFICATION',\n  DELETE: 'MODIFICATION',\n  UPDATE: 'MODIFICATION',\n  CREATE_DATABASE: 'MODIFICATION',\n  CREATE_TABLE: 'MODIFICATION',\n  CREATE_TRIGGER: 'MODIFICATION',\n  DROP_DATABASE: 'MODIFICATION',\n  DROP_TABLE: 'MODIFICATION',\n  TRUNCATE: 'MODIFICATION',\n  UNKNOWN: 'UNKNOWN',\n};\n\nconst dialectsWithEnds = ['sqlite', 'mssql'];\n\n/**\n * Parser\n */\nexport function parse (input, isStrict = true, dialect = 'generic') {\n  const topLevelState = initState({ input });\n  const topLevelStatement = {\n    type: 'QUERY',\n    start: 0,\n    end: input.length - 1,\n    body: [],\n    tokens: [],\n  };\n\n  let prevState = topLevelState;\n  let statementParser;\n\n  const ignoreOutsideBlankTokens = [\n    'whitespace',\n    'comment-inline',\n    'comment-block',\n  ];\n\n  while (prevState.position < topLevelState.end) {\n    const tokenState = initState({ prevState });\n    const token = scanToken(tokenState);\n\n    if (!statementParser) {\n      // ignore blank tokens that are not in a statement\n      if (ignoreOutsideBlankTokens.includes(token.type)) {\n        topLevelStatement.tokens.push(token);\n        prevState = tokenState;\n        continue;\n      }\n\n      statementParser = createStatementParserByToken(token, { isStrict, dialect });\n    }\n\n    statementParser.addToken(token);\n    topLevelStatement.tokens.push(token);\n    prevState = tokenState;\n\n    const statement = statementParser.getStatement();\n    if (statement.endStatement) {\n      statement.end = token.end;\n      topLevelStatement.body.push(statement);\n      statementParser = null;\n    }\n  }\n\n  // last statement without ending key\n  if (statementParser) {\n    const statement = statementParser.getStatement();\n    if (!statement.endStatement) {\n      statement.end = topLevelStatement.end;\n      topLevelStatement.body.push(statement);\n    }\n  }\n\n  return topLevelStatement;\n}\n\nfunction initState ({ input, prevState }) {\n  if (prevState) {\n    return {\n      input: prevState.input,\n      position: prevState.position,\n      start: prevState.position + 1,\n      end: prevState.input.length - 1,\n      body: [],\n    };\n  }\n\n  return {\n    input,\n    position: -1,\n    start: 0,\n    end: input.length - 1,\n    body: [],\n  };\n}\n\nfunction createStatementParserByToken (token, options) {\n  if (token.type === 'keyword') {\n    switch (token.value.toUpperCase()) {\n      case 'SELECT': return createSelectStatementParser(options);\n      case 'CREATE': return createCreateStatementParser(options);\n      case 'DROP': return createDropStatementParser(options);\n      case 'INSERT': return createInsertStatementParser(options);\n      case 'UPDATE': return createUpdateStatementParser(options);\n      case 'DELETE': return createDeleteStatementParser(options);\n      case 'TRUNCATE': return createTruncateStatementParser(options);\n      default: break;\n    }\n  }\n\n  if (!options.isStrict && token.type === 'unknown') {\n    return createUnknownStatementParser(options.isStrict);\n  }\n\n  throw new Error(`Invalid statement parser \"${token.value}\"`);\n}\n\nfunction createSelectStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Select\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'SELECT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'SELECT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createInsertStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Insert\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'INSERT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'INSERT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createUpdateStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Update\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'UPDATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'UPDATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createDeleteStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Delete\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DELETE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'DELETE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createCreateStatementParser ({ isStrict, dialect }) {\n  const statement = {};\n\n  const steps = [\n    // Create\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'CREATE' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n          { type: 'keyword', value: 'TRIGGER' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `CREATE_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict, dialect });\n}\n\nfunction createDropStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    // Drop\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DROP' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `DROP_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createTruncateStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'TRUNCATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'TRUNCATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction createUnknownStatementParser ({ isStrict }) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      add: (token) => {\n        statement.type = 'UNKNOWN';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps, { isStrict });\n}\n\nfunction stateMachineStatementParser (statement, steps, { isStrict, dialect = 'generic' }) {\n  let currentStepIndex = 0;\n  let prevToken;\n\n  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n  const isValidToken = (step, token) => {\n    if (!step.validation) {\n      return true;\n    }\n\n    return step\n      .validation\n      .acceptTokens.filter((accept) => {\n        const isValidType = token.type === accept.type;\n        const isValidValue = (\n          !accept.value\n          || token.value.toUpperCase() === accept.value\n        );\n\n        return isValidType && isValidValue;\n      }).length > 0;\n  };\n\n  const hasRequiredBefore = (step) => {\n    return (\n      !step.requireBefore\n      || step.requireBefore.includes(prevToken.type)\n    );\n  };\n\n  return {\n    getStatement () {\n      return statement;\n    },\n\n    addToken (token) {\n      /* eslint no-param-reassign: 0 */\n      if (statement.endStatement) {\n        throw new Error('This statement has already got to the end.');\n      }\n\n      if (token.type === 'semicolon') {\n        // SQLite and MSSQL require semi-colons inside the trigger. They signify the end of the trigger creation\n        // with `END;`. This allows detection of that.\n        if (dialectsWithEnds.includes(dialect) && (statement.type === 'CREATE_TRIGGER' && !statement.canEnd)) {\n          // do nothing\n        } else {\n          statement.endStatement = ';';\n          return;\n        }\n      }\n\n      // SQLite and MSSQL triggers use `END;` to signify the end of the statement. The statement can include other semicolons.\n      if (dialectsWithEnds.includes(dialect) && token.value === 'END' && statement.type === 'CREATE_TRIGGER') {\n        statement.canEnd = true;\n        return;\n      }\n\n      if (token.type === 'whitespace') {\n        prevToken = token;\n        return;\n      }\n\n      if (statement.type) {\n        // statement has already been identified\n        // just wait until end of the statement\n        return;\n      }\n\n      let currentStep = steps[currentStepIndex];\n      if (currentStep.preCanGoToNext(token)) {\n        currentStepIndex++;\n        currentStep = steps[currentStepIndex];\n      }\n\n      if (!hasRequiredBefore(currentStep)) {\n        const requireds = currentStep.requireBefore.join(' or ');\n        throw new Error(`Expected any of these tokens ${requireds} before \"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      if (!isValidToken(currentStep, token) && isStrict) {\n        const expecteds = currentStep\n          .validation\n          .acceptTokens\n          .map((accept) => `(type=\"${accept.type}\" value=\"${accept.value}\")`)\n          .join(' or ');\n        throw new Error(`Expected any of these tokens ${expecteds} instead of type=\"${token.type}\" value=\"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      currentStep.add(token);\n\n      statement.executionType = EXECUTION_TYPES[statement.type] || 'UNKNOWN';\n\n      if (currentStep.postCanGoToNext(token)) {\n        currentStepIndex++;\n      }\n\n      prevToken = token;\n    },\n  };\n}\n","import { parse } from './parser';\n\nconst allowedDialects = ['mssql', 'sqlite', 'mysql', 'psql', 'generic'];\n/**\n * Identifier\n */\nexport function identify (query, options = {}) {\n  const isStrict = typeof options.strict === 'undefined' ? true : options.strict;\n  const dialect = typeof options.dialect === 'undefined' ? 'generic' : options.dialect;\n\n  if (!allowedDialects.includes(dialect)) {\n    throw new Error(`Unknown dialect. Allowed values: ${allowedDialects.join(',')}`);\n  }\n\n  const result = parse(query, isStrict, dialect);\n\n  return result.body.map((statement) => ({\n    start: statement.start,\n    end: statement.end,\n    text: query.substring(statement.start, statement.end + 1),\n    type: statement.type,\n    executionType: statement.executionType,\n  }));\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(468);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}