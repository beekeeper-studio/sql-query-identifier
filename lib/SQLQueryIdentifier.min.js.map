{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///SQLQueryIdentifier.min.js","webpack:///webpack/bootstrap a7a0657a961e4167f87f","webpack:///./src/index.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","identify","query","options","arguments","length","undefined","isStrict","strict","result","_parser","parse","body","map","statement","start","end","text","substring","type","executionType","Object","defineProperty","value","input","topLevelState","initState","topLevelStatement","tokens","prevState","statementParser","ignoreOutsideBlankTokens","position","tokenState","token","_tokenizer","scanToken","indexOf","push","createStatementParserByToken","addToken","getStatement","endStatement","_statement","_ref","toUpperCase","createSelectStatementParser","createCreateStatementParser","createDropStatementParser","createInsertStatementParser","createUpdateStatementParser","createDeleteStatementParser","createTruncateStatementParser","createUnknownStatementParser","Error","steps","preCanGoToNext","validation","acceptTokens","add","postCanGoToNext","stateMachineStatementParser","requireBefore","currentStepIndex","prevToken","isValidToken","step","filter","accept","isValidType","isValidValue","hasRequiredBefore","currentStep","requireds","join","expecteds","EXECUTION_TYPES","SELECT","INSERT","DELETE","UPDATE","CREATE_DATABASE","CREATE_TABLE","DROP_DATABASE","DROP_TABLE","TRUNCATE","UNKNOWN","state","ch","read","isWhitespace","scanWhitespace","isCommentInline","scanCommentInline","isCommentBlock","scanCommentBlock","isString","scanString","isLetter","scanWord","individual","scanIndividualCharacter","skipChar","unread","isKeyword","word","KEYWORDS","resolveIndividualTokenType","INDIVIDUALS","nextChar","slice","prevChar","skipWord","isComment",";"],"mappings":"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","file":"SQLQueryIdentifier.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.identify = identify;\n\t\n\tvar _parser = __webpack_require__(1);\n\t\n\t/**\n\t * Identifier\n\t */\n\tfunction identify(query) {\n\t  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t  var isStrict = typeof options.strict === 'undefined' ? true : options.strict;\n\t\n\t  var result = (0, _parser.parse)(query, isStrict);\n\t\n\t  return result.body.map(function (statement) {\n\t    return {\n\t      start: statement.start,\n\t      end: statement.end,\n\t      text: query.substring(statement.start, statement.end + 1),\n\t      type: statement.type,\n\t      executionType: statement.executionType\n\t    };\n\t  });\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.parse = parse;\n\t\n\tvar _tokenizer = __webpack_require__(2);\n\t\n\t/**\n\t * Execution types allow to know what is the query behavior\n\t *  - LISTING: is when the query list the data\n\t *  - MODIFICATION: is when the query modificate the database somehow (structure or data)\n\t *  - INFORMATION: is show some data information such as a profile data\n\t *  - UNKNOWN\n\t */\n\tvar EXECUTION_TYPES = {\n\t  SELECT: 'LISTING',\n\t  INSERT: 'MODIFICATION',\n\t  DELETE: 'MODIFICATION',\n\t  UPDATE: 'MODIFICATION',\n\t  CREATE_DATABASE: 'MODIFICATION',\n\t  CREATE_TABLE: 'MODIFICATION',\n\t  DROP_DATABASE: 'MODIFICATION',\n\t  DROP_TABLE: 'MODIFICATION',\n\t  TRUNCATE: 'MODIFICATION',\n\t  UNKNOWN: 'UNKNOWN'\n\t};\n\t\n\t/**\n\t * Parser\n\t */\n\tfunction parse(input) {\n\t  var isStrict = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\t\n\t  var topLevelState = initState({ input: input });\n\t  var topLevelStatement = {\n\t    type: 'QUERY',\n\t    start: 0,\n\t    end: input.length - 1,\n\t    body: [],\n\t    tokens: []\n\t  };\n\t\n\t  var prevState = topLevelState;\n\t  var statementParser = void 0;\n\t\n\t  var ignoreOutsideBlankTokens = ['whitespace', 'comment-inline', 'comment-block'];\n\t\n\t  while (prevState.position < topLevelState.end) {\n\t    var tokenState = initState({ prevState: prevState });\n\t    var token = (0, _tokenizer.scanToken)(tokenState);\n\t\n\t    if (!statementParser) {\n\t      // ignore blank tokens that are not in a statement\n\t      if (~ignoreOutsideBlankTokens.indexOf(token.type)) {\n\t        topLevelStatement.tokens.push(token);\n\t        prevState = tokenState;\n\t        continue;\n\t      }\n\t\n\t      statementParser = createStatementParserByToken(isStrict, token);\n\t    }\n\t\n\t    statementParser.addToken(token);\n\t    topLevelStatement.tokens.push(token);\n\t    prevState = tokenState;\n\t\n\t    var statement = statementParser.getStatement();\n\t    if (statement.endStatement) {\n\t      statement.end = token.end;\n\t      topLevelStatement.body.push(statement);\n\t      statementParser = null;\n\t    }\n\t  }\n\t\n\t  // last statement without ending key\n\t  if (statementParser) {\n\t    var _statement = statementParser.getStatement();\n\t    if (!_statement.endStatement) {\n\t      _statement.end = topLevelStatement.end;\n\t      topLevelStatement.body.push(_statement);\n\t    }\n\t  }\n\t\n\t  return topLevelStatement;\n\t}\n\t\n\tfunction initState(_ref) {\n\t  var input = _ref.input;\n\t  var prevState = _ref.prevState;\n\t\n\t  if (prevState) {\n\t    return {\n\t      input: prevState.input,\n\t      position: prevState.position,\n\t      start: prevState.position + 1,\n\t      end: prevState.input.length - 1,\n\t      body: []\n\t    };\n\t  }\n\t\n\t  return {\n\t    input: input,\n\t    position: -1,\n\t    start: 0,\n\t    end: input.length - 1,\n\t    body: []\n\t  };\n\t}\n\t\n\tfunction createStatementParserByToken(isStrict, token) {\n\t  if (token.type === 'keyword') {\n\t    switch (token.value.toUpperCase()) {\n\t      case 'SELECT':\n\t        return createSelectStatementParser(isStrict);\n\t      case 'CREATE':\n\t        return createCreateStatementParser(isStrict);\n\t      case 'DROP':\n\t        return createDropStatementParser(isStrict);\n\t      case 'INSERT':\n\t        return createInsertStatementParser(isStrict);\n\t      case 'UPDATE':\n\t        return createUpdateStatementParser(isStrict);\n\t      case 'DELETE':\n\t        return createDeleteStatementParser(isStrict);\n\t      case 'TRUNCATE':\n\t        return createTruncateStatementParser(isStrict);\n\t      default:\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!isStrict && token.type === 'unknown') {\n\t    return createUnknownStatementParser(isStrict);\n\t  }\n\t\n\t  throw new Error('Invalid statement parser \"' + token.value + '\"');\n\t}\n\t\n\tfunction createSelectStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Select\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'SELECT' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'SELECT';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createInsertStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Insert\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'INSERT' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'INSERT';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createUpdateStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Update\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'UPDATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'UPDATE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createDeleteStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Delete\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'DELETE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'DELETE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createCreateStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Create\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'CREATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  },\n\t  // Table/Database\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      requireBefore: ['whitespace'],\n\t      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'CREATE_' + token.value.toUpperCase();\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createDropStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Drop\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'DROP' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  },\n\t  // Table/Database\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      requireBefore: ['whitespace'],\n\t      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'DROP_' + token.value.toUpperCase();\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createTruncateStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [{\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'TRUNCATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'TRUNCATE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction createUnknownStatementParser(isStrict) {\n\t  var statement = {};\n\t\n\t  var steps = [{\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'UNKNOWN';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(isStrict, statement, steps);\n\t}\n\t\n\tfunction stateMachineStatementParser(isStrict, statement, steps) {\n\t  var currentStepIndex = 0;\n\t  var prevToken = void 0;\n\t\n\t  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n\t  var isValidToken = function isValidToken(step, token) {\n\t    if (!step.validation) {\n\t      return true;\n\t    }\n\t\n\t    return step.validation.acceptTokens.filter(function (accept) {\n\t      var isValidType = token.type === accept.type;\n\t      var isValidValue = !accept.value || token.value.toUpperCase() === accept.value;\n\t\n\t      return isValidType && isValidValue;\n\t    }).length > 0;\n\t  };\n\t\n\t  var hasRequiredBefore = function hasRequiredBefore(step) {\n\t    return !step.requireBefore || ~step.requireBefore.indexOf(prevToken.type);\n\t  };\n\t\n\t  return {\n\t    getStatement: function getStatement() {\n\t      return statement;\n\t    },\n\t    addToken: function addToken(token) {\n\t      /* eslint no-param-reassign: 0 */\n\t      if (statement.endStatement) {\n\t        throw new Error('This statement has already got to the end.');\n\t      }\n\t\n\t      if (token.type === 'semicolon') {\n\t        statement.endStatement = ';';\n\t        return;\n\t      }\n\t\n\t      if (token.type === 'whitespace') {\n\t        prevToken = token;\n\t        return;\n\t      }\n\t\n\t      if (statement.type) {\n\t        // statement has already been identified\n\t        // just wait until end of the statement\n\t        return;\n\t      }\n\t\n\t      var currentStep = steps[currentStepIndex];\n\t      if (currentStep.preCanGoToNext(token)) {\n\t        currentStepIndex++;\n\t        currentStep = steps[currentStepIndex];\n\t      }\n\t\n\t      if (!hasRequiredBefore(currentStep)) {\n\t        var requireds = currentStep.requireBefore.join(' or ');\n\t        throw new Error('Expected any of these tokens ' + requireds + ' before \"' + token.value + '\" (currentStep=' + currentStepIndex + ').');\n\t      }\n\t\n\t      if (!isValidToken(currentStep, token) && isStrict) {\n\t        var expecteds = currentStep.validation.acceptTokens.map(function (accept) {\n\t          return '(type=\"' + accept.type + '\" value=\"' + accept.value + '\")';\n\t        }).join(' or ');\n\t        throw new Error('Expected any of these tokens ' + expecteds + ' instead of type=\"' + token.type + '\" value=\"' + token.value + '\" (currentStep=' + currentStepIndex + ').');\n\t      }\n\t\n\t      currentStep.add(token);\n\t\n\t      statement.executionType = EXECUTION_TYPES[statement.type] || 'UNKNOWN';\n\t\n\t      if (currentStep.postCanGoToNext(token)) {\n\t        currentStepIndex++;\n\t      }\n\t\n\t      prevToken = token;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.scanToken = scanToken;\n\t/**\n\t * Tokenizer\n\t */\n\t\n\t/* eslint no-param-reassign: 0 */\n\tvar KEYWORDS = ['SELECT', 'INSERT', 'DELETE', 'UPDATE', 'CREATE', 'DROP', 'TABLE', 'DATABASE', 'TRUNCATE'];\n\t\n\tvar INDIVIDUALS = {\n\t  ';': 'semicolon'\n\t};\n\t\n\tfunction scanToken(state) {\n\t  var ch = read(state);\n\t\n\t  if (isWhitespace(ch)) {\n\t    return scanWhitespace(state);\n\t  }\n\t\n\t  if (isCommentInline(ch, state)) {\n\t    return scanCommentInline(state);\n\t  }\n\t\n\t  if (isCommentBlock(ch, state)) {\n\t    return scanCommentBlock(state);\n\t  }\n\t\n\t  if (isString(ch, state)) {\n\t    return scanString(state);\n\t  }\n\t\n\t  if (isLetter(ch)) {\n\t    return scanWord(state);\n\t  }\n\t\n\t  var individual = scanIndividualCharacter(state);\n\t  if (individual) {\n\t    return individual;\n\t  }\n\t\n\t  return skipChar(state);\n\t}\n\t\n\tfunction read(state) {\n\t  if (state.position === state.input.length - 1) {\n\t    return null;\n\t  }\n\t\n\t  state.position++;\n\t  return state.input[state.position];\n\t}\n\t\n\tfunction unread(state) {\n\t  if (state.position === state.start) {\n\t    return;\n\t  }\n\t\n\t  state.position--;\n\t}\n\t\n\tfunction isKeyword(word) {\n\t  return ~KEYWORDS.indexOf(word.toUpperCase());\n\t}\n\t\n\tfunction resolveIndividualTokenType(ch) {\n\t  return INDIVIDUALS[ch];\n\t}\n\t\n\tfunction scanWhitespace(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (isWhitespace(nextChar));\n\t\n\t  if (nextChar !== null && !isWhitespace(nextChar)) {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'whitespace',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanCommentInline(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (nextChar !== '\\n' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '\\n') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'comment-inline',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanString(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (nextChar !== '\\'' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '\\'') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'string',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanCommentBlock(state) {\n\t  var nextChar = void 0;\n\t  var prevChar = void 0;\n\t\n\t  do {\n\t    prevChar = nextChar;\n\t    nextChar = read(state);\n\t  } while (prevChar + nextChar !== '*/' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '/') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'comment-block',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanWord(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (isLetter(nextChar));\n\t\n\t  if (nextChar !== null && !isLetter(nextChar)) {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  if (!isKeyword(value)) {\n\t    return skipWord(state, value);\n\t  }\n\t\n\t  return {\n\t    type: 'keyword',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanIndividualCharacter(state) {\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  var type = resolveIndividualTokenType(value);\n\t  if (!type) {\n\t    return null;\n\t  }\n\t\n\t  return {\n\t    type: type,\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction skipChar(state) {\n\t  return {\n\t    type: 'unknown',\n\t    value: state.input.slice(state.start, state.position + 1),\n\t    start: state.start,\n\t    end: state.start\n\t  };\n\t}\n\t\n\tfunction skipWord(state, value) {\n\t  return {\n\t    type: 'unknown',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction isWhitespace(ch) {\n\t  return ch === ' ' || ch === '\\t' || ch === '\\n';\n\t}\n\t\n\tfunction isString(ch) {\n\t  return ch === '\\'';\n\t}\n\t\n\tfunction isCommentInline(ch, state) {\n\t  var isComment = ch === '-';\n\t  if (!isComment) {\n\t    return false;\n\t  }\n\t\n\t  // lookahead\n\t  var nextChar = read(state);\n\t  isComment = nextChar === '-';\n\t  if (!isComment) {\n\t    unread(state);\n\t  }\n\t\n\t  return isComment;\n\t}\n\t\n\tfunction isCommentBlock(ch, state) {\n\t  var isComment = ch === '/';\n\t  if (!isComment) {\n\t    return false;\n\t  }\n\t\n\t  // lookahead\n\t  var nextChar = read(state);\n\t  isComment = nextChar === '*';\n\t  if (!isComment) {\n\t    unread(state);\n\t  }\n\t\n\t  return isComment;\n\t}\n\t\n\tfunction isLetter(ch) {\n\t  return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// SQLQueryIdentifier.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a7a0657a961e4167f87f","import { parse } from './parser';\n\n\n/**\n * Identifier\n */\nexport function identify (query, options = {}) {\n  const isStrict = typeof options.strict === 'undefined' ? true : options.strict;\n\n  const result = parse(query, isStrict);\n\n  return result.body.map(statement => ({\n    start: statement.start,\n    end: statement.end,\n    text: query.substring(statement.start, statement.end + 1),\n    type: statement.type,\n    executionType: statement.executionType,\n  }));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { scanToken } from './tokenizer';\n\n/**\n * Execution types allow to know what is the query behavior\n *  - LISTING: is when the query list the data\n *  - MODIFICATION: is when the query modificate the database somehow (structure or data)\n *  - INFORMATION: is show some data information such as a profile data\n *  - UNKNOWN\n */\nconst EXECUTION_TYPES = {\n  SELECT: 'LISTING',\n  INSERT: 'MODIFICATION',\n  DELETE: 'MODIFICATION',\n  UPDATE: 'MODIFICATION',\n  CREATE_DATABASE: 'MODIFICATION',\n  CREATE_TABLE: 'MODIFICATION',\n  DROP_DATABASE: 'MODIFICATION',\n  DROP_TABLE: 'MODIFICATION',\n  TRUNCATE: 'MODIFICATION',\n  UNKNOWN: 'UNKNOWN',\n};\n\n/**\n * Parser\n */\nexport function parse (input, isStrict = true) {\n  const topLevelState = initState({ input });\n  const topLevelStatement = {\n    type: 'QUERY',\n    start: 0,\n    end: input.length - 1,\n    body: [],\n    tokens: [],\n  };\n\n  let prevState = topLevelState;\n  let statementParser;\n\n  const ignoreOutsideBlankTokens = [\n    'whitespace',\n    'comment-inline',\n    'comment-block',\n  ];\n\n  while (prevState.position < topLevelState.end) {\n    const tokenState = initState({ prevState });\n    const token = scanToken(tokenState);\n\n    if (!statementParser) {\n      // ignore blank tokens that are not in a statement\n      if (~ignoreOutsideBlankTokens.indexOf(token.type)) {\n        topLevelStatement.tokens.push(token);\n        prevState = tokenState;\n        continue;\n      }\n\n      statementParser = createStatementParserByToken(isStrict, token);\n    }\n\n    statementParser.addToken(token);\n    topLevelStatement.tokens.push(token);\n    prevState = tokenState;\n\n    const statement = statementParser.getStatement();\n    if (statement.endStatement) {\n      statement.end = token.end;\n      topLevelStatement.body.push(statement);\n      statementParser = null;\n    }\n  }\n\n  // last statement without ending key\n  if (statementParser) {\n    const statement = statementParser.getStatement();\n    if (!statement.endStatement) {\n      statement.end = topLevelStatement.end;\n      topLevelStatement.body.push(statement);\n    }\n  }\n\n  return topLevelStatement;\n}\n\n\nfunction initState ({ input, prevState }) {\n  if (prevState) {\n    return {\n      input: prevState.input,\n      position: prevState.position,\n      start: prevState.position + 1,\n      end: prevState.input.length - 1,\n      body: [],\n    };\n  }\n\n  return {\n    input,\n    position: -1,\n    start: 0,\n    end: input.length - 1,\n    body: [],\n  };\n}\n\n\nfunction createStatementParserByToken (isStrict, token) {\n  if (token.type === 'keyword') {\n    switch (token.value.toUpperCase()) {\n      case 'SELECT': return createSelectStatementParser(isStrict);\n      case 'CREATE': return createCreateStatementParser(isStrict);\n      case 'DROP': return createDropStatementParser(isStrict);\n      case 'INSERT': return createInsertStatementParser(isStrict);\n      case 'UPDATE': return createUpdateStatementParser(isStrict);\n      case 'DELETE': return createDeleteStatementParser(isStrict);\n      case 'TRUNCATE': return createTruncateStatementParser(isStrict);\n      default: break;\n    }\n  }\n\n  if (!isStrict && token.type === 'unknown') {\n    return createUnknownStatementParser(isStrict);\n  }\n\n  throw new Error(`Invalid statement parser \"${token.value}\"`);\n}\n\n\nfunction createSelectStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Select\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'SELECT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'SELECT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createInsertStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Insert\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'INSERT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'INSERT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createUpdateStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Update\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'UPDATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'UPDATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createDeleteStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Delete\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DELETE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'DELETE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createCreateStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Create\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'CREATE' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `CREATE_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createDropStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    // Drop\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DROP' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `DROP_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createTruncateStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'TRUNCATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'TRUNCATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction createUnknownStatementParser (isStrict) {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      add: (token) => {\n        statement.type = 'UNKNOWN';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(isStrict, statement, steps);\n}\n\n\nfunction stateMachineStatementParser (isStrict, statement, steps) {\n  let currentStepIndex = 0;\n  let prevToken;\n\n  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n  const isValidToken = (step, token) => {\n    if (!step.validation) {\n      return true;\n    }\n\n    return step\n      .validation\n      .acceptTokens.filter(accept => {\n        const isValidType = token.type === accept.type;\n        const isValidValue = (\n          !accept.value\n          || token.value.toUpperCase() === accept.value\n        );\n\n        return isValidType && isValidValue;\n      }).length > 0;\n  };\n\n  const hasRequiredBefore = (step) => {\n    return (\n      !step.requireBefore\n      || ~step.requireBefore.indexOf(prevToken.type)\n    );\n  };\n\n  return {\n    getStatement () {\n      return statement;\n    },\n\n    addToken (token) {\n      /* eslint no-param-reassign: 0 */\n      if (statement.endStatement) {\n        throw new Error('This statement has already got to the end.');\n      }\n\n      if (token.type === 'semicolon') {\n        statement.endStatement = ';';\n        return;\n      }\n\n      if (token.type === 'whitespace') {\n        prevToken = token;\n        return;\n      }\n\n      if (statement.type) {\n        // statement has already been identified\n        // just wait until end of the statement\n        return;\n      }\n\n      let currentStep = steps[currentStepIndex];\n      if (currentStep.preCanGoToNext(token)) {\n        currentStepIndex++;\n        currentStep = steps[currentStepIndex];\n      }\n\n      if (!hasRequiredBefore(currentStep)) {\n        const requireds = currentStep.requireBefore.join(' or ');\n        throw new Error(`Expected any of these tokens ${requireds} before \"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      if (!isValidToken(currentStep, token) && isStrict) {\n        const expecteds = currentStep\n          .validation\n          .acceptTokens\n          .map(accept => `(type=\"${accept.type}\" value=\"${accept.value}\")`)\n          .join(' or ');\n        throw new Error(`Expected any of these tokens ${expecteds} instead of type=\"${token.type}\" value=\"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      currentStep.add(token);\n\n      statement.executionType = EXECUTION_TYPES[statement.type] || 'UNKNOWN';\n\n      if (currentStep.postCanGoToNext(token)) {\n        currentStepIndex++;\n      }\n\n      prevToken = token;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","/**\n * Tokenizer\n */\n\n/* eslint no-param-reassign: 0 */\nconst KEYWORDS = [\n  'SELECT',\n  'INSERT',\n  'DELETE',\n  'UPDATE',\n  'CREATE',\n  'DROP',\n  'TABLE',\n  'DATABASE',\n  'TRUNCATE',\n];\n\n\nconst INDIVIDUALS = {\n  ';': 'semicolon',\n};\n\n\nexport function scanToken (state) {\n  const ch = read(state);\n\n  if (isWhitespace(ch)) {\n    return scanWhitespace(state);\n  }\n\n  if (isCommentInline(ch, state)) {\n    return scanCommentInline(state);\n  }\n\n  if (isCommentBlock(ch, state)) {\n    return scanCommentBlock(state);\n  }\n\n  if (isString(ch, state)) {\n    return scanString(state);\n  }\n\n  if (isLetter(ch)) {\n    return scanWord(state);\n  }\n\n  const individual = scanIndividualCharacter(state);\n  if (individual) {\n    return individual;\n  }\n\n  return skipChar(state);\n}\n\n\nfunction read (state) {\n  if (state.position === state.input.length - 1) {\n    return null;\n  }\n\n  state.position++;\n  return state.input[state.position];\n}\n\nfunction unread (state) {\n  if (state.position === state.start) {\n    return;\n  }\n\n  state.position--;\n}\n\n\nfunction isKeyword (word) {\n  return ~KEYWORDS.indexOf(word.toUpperCase());\n}\n\n\nfunction resolveIndividualTokenType (ch) {\n  return INDIVIDUALS[ch];\n}\n\n\nfunction scanWhitespace (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isWhitespace(nextChar));\n\n  if (nextChar !== null && !isWhitespace(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'whitespace',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanCommentInline (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\n' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\n') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-inline',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanString (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\'' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\'') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'string',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanCommentBlock (state) {\n  let nextChar;\n  let prevChar;\n\n  do {\n    prevChar = nextChar;\n    nextChar = read(state);\n  } while ((prevChar + nextChar !== '*/') && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '/') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-block',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanWord (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isLetter(nextChar));\n\n  if (nextChar !== null && !isLetter(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  if (!isKeyword(value)) {\n    return skipWord(state, value);\n  }\n\n  return {\n    type: 'keyword',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanIndividualCharacter (state) {\n  const value = state.input.slice(state.start, state.position + 1);\n  const type = resolveIndividualTokenType(value);\n  if (!type) {\n    return null;\n  }\n\n  return {\n    type,\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction skipChar (state) {\n  return {\n    type: 'unknown',\n    value: state.input.slice(state.start, state.position + 1),\n    start: state.start,\n    end: state.start,\n  };\n}\n\n\nfunction skipWord (state, value) {\n  return {\n    type: 'unknown',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction isWhitespace (ch) {\n  return ch === ' ' || ch === '\\t' || ch === '\\n';\n}\n\nfunction isString (ch) {\n  return ch === '\\'';\n}\n\n\nfunction isCommentInline (ch, state) {\n  let isComment = ch === '-';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '-';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\n\nfunction isCommentBlock (ch, state) {\n  let isComment = ch === '/';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '*';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\n\nfunction isLetter (ch) {\n  return (ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z');\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js"],"sourceRoot":""}