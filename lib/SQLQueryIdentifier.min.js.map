{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///SQLQueryIdentifier.min.js","webpack:///webpack/bootstrap b884d0a5cf31df5c1d3d","webpack:///./src/index.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","identify","query","result","_parser","parse","body","map","statement","start","end","text","substring","type","Object","defineProperty","value","input","topLevelState","initState","topLevelStatement","length","tokens","prevState","statementParser","position","tokenState","token","_tokenizer","scanToken","push","createStatementParserByToken","addToken","getStatement","endStatement","_statement","_ref","toUpperCase","createSelectStatementParser","createCreateStatementParser","createDropStatementParser","createInsertStatementParser","createUpdateStatementParser","createDeleteStatementParser","createTruncateStatementParser","Error","steps","preCanGoToNext","validation","acceptTokens","add","postCanGoToNext","stateMachineStatementParser","requireBefore","currentStepIndex","prevToken","isValidToken","step","filter","accept","isValidType","isValidValue","hasRequiredBefore","indexOf","currentStep","requireds","join","expecteds","state","ch","read","isWhitespace","scanWhitespace","isCommentInline","scanCommentInline","isCommentBlock","scanCommentBlock","isString","scanString","isLetter","scanWord","individual","scanIndividualCharacter","skipChar","unread","isKeyword","word","KEYWORDS","resolveIndividualTokenType","INDIVIDUALS","nextChar","slice","prevChar","skipWord","isComment",";"],"mappings":"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","file":"SQLQueryIdentifier.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SQLQueryIdentifier\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SQLQueryIdentifier\"] = factory();\n\telse\n\t\troot[\"SQLQueryIdentifier\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.identify = identify;\n\t\n\tvar _parser = __webpack_require__(1);\n\t\n\t/**\n\t * Identifier\n\t */\n\tfunction identify(query) {\n\t  var result = (0, _parser.parse)(query);\n\t\n\t  return result.body.map(function (statement) {\n\t    return {\n\t      start: statement.start,\n\t      end: statement.end,\n\t      text: query.substring(statement.start, statement.end + 1),\n\t      type: statement.type\n\t    };\n\t  });\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.parse = parse;\n\t\n\tvar _tokenizer = __webpack_require__(2);\n\t\n\t/**\n\t * Parser\n\t */\n\tfunction parse(input) {\n\t  var topLevelState = initState({ input: input });\n\t  var topLevelStatement = {\n\t    type: 'QUERY',\n\t    start: 0,\n\t    end: input.length - 1,\n\t    body: [],\n\t    tokens: []\n\t  };\n\t\n\t  var prevState = topLevelState;\n\t  var statementParser = void 0;\n\t\n\t  while (prevState.position < topLevelState.end) {\n\t    var tokenState = initState({ prevState: prevState });\n\t    var token = (0, _tokenizer.scanToken)(tokenState);\n\t\n\t    if (!statementParser) {\n\t      // ignore white spaces between statements\n\t      if (token.type === 'whitespace') {\n\t        topLevelStatement.tokens.push(token);\n\t        prevState = tokenState;\n\t        continue;\n\t      }\n\t\n\t      statementParser = createStatementParserByToken(token);\n\t    }\n\t\n\t    statementParser.addToken(token);\n\t    topLevelStatement.tokens.push(token);\n\t    prevState = tokenState;\n\t\n\t    var statement = statementParser.getStatement();\n\t    if (statement.endStatement) {\n\t      statement.end = token.end;\n\t      topLevelStatement.body.push(statement);\n\t      statementParser = null;\n\t    }\n\t  }\n\t\n\t  // last statement without ending key\n\t  if (statementParser) {\n\t    var _statement = statementParser.getStatement();\n\t    if (!_statement.endStatement) {\n\t      _statement.end = topLevelStatement.end;\n\t      topLevelStatement.body.push(_statement);\n\t    }\n\t  }\n\t\n\t  return topLevelStatement;\n\t}\n\t\n\tfunction initState(_ref) {\n\t  var input = _ref.input;\n\t  var prevState = _ref.prevState;\n\t\n\t  if (prevState) {\n\t    return {\n\t      input: prevState.input,\n\t      position: prevState.position,\n\t      start: prevState.position + 1,\n\t      end: prevState.input.length - 1,\n\t      body: []\n\t    };\n\t  }\n\t\n\t  return {\n\t    input: input,\n\t    position: -1,\n\t    start: 0,\n\t    end: input.length - 1,\n\t    body: []\n\t  };\n\t}\n\t\n\tfunction createStatementParserByToken(token) {\n\t  if (token.type === 'keyword') {\n\t    switch (token.value.toUpperCase()) {\n\t      case 'SELECT':\n\t        return createSelectStatementParser();\n\t      case 'CREATE':\n\t        return createCreateStatementParser();\n\t      case 'DROP':\n\t        return createDropStatementParser();\n\t      case 'INSERT':\n\t        return createInsertStatementParser();\n\t      case 'UPDATE':\n\t        return createUpdateStatementParser();\n\t      case 'DELETE':\n\t        return createDeleteStatementParser();\n\t      case 'TRUNCATE':\n\t        return createTruncateStatementParser();\n\t      default:\n\t        break;\n\t    }\n\t  }\n\t\n\t  throw new Error('Invalid statement parser \"' + token.value + '\"');\n\t}\n\t\n\tfunction createSelectStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Select\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'SELECT' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'SELECT';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createInsertStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Insert\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'INSERT' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'INSERT';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createUpdateStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Update\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'UPDATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'UPDATE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createDeleteStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Delete\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'DELETE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'DELETE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createCreateStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Create\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'CREATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  },\n\t  // Table/Database\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      requireBefore: ['whitespace'],\n\t      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'CREATE_' + token.value.toUpperCase();\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createDropStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [\n\t  // Drop\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'DROP' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  },\n\t  // Table/Database\n\t  {\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      requireBefore: ['whitespace'],\n\t      acceptTokens: [{ type: 'keyword', value: 'TABLE' }, { type: 'keyword', value: 'DATABASE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'DROP_' + token.value.toUpperCase();\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction createTruncateStatementParser() {\n\t  var statement = {};\n\t\n\t  var steps = [{\n\t    preCanGoToNext: function preCanGoToNext() {\n\t      return false;\n\t    },\n\t    validation: {\n\t      acceptTokens: [{ type: 'keyword', value: 'TRUNCATE' }]\n\t    },\n\t    add: function add(token) {\n\t      statement.type = 'TRUNCATE';\n\t      statement.start = token.start;\n\t    },\n\t    postCanGoToNext: function postCanGoToNext() {\n\t      return true;\n\t    }\n\t  }];\n\t\n\t  return stateMachineStatementParser(statement, steps);\n\t}\n\t\n\tfunction stateMachineStatementParser(statement, steps) {\n\t  var currentStepIndex = 0;\n\t  var prevToken = void 0;\n\t\n\t  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n\t  var isValidToken = function isValidToken(step, token) {\n\t    return step.validation.acceptTokens.filter(function (accept) {\n\t      var isValidType = token.type === accept.type;\n\t      var isValidValue = !accept.value || token.value.toUpperCase() === accept.value;\n\t\n\t      return isValidType && isValidValue;\n\t    }).length > 0;\n\t  };\n\t\n\t  var hasRequiredBefore = function hasRequiredBefore(step) {\n\t    return !step.requireBefore || ~step.requireBefore.indexOf(prevToken.type);\n\t  };\n\t\n\t  return {\n\t    getStatement: function getStatement() {\n\t      return statement;\n\t    },\n\t    addToken: function addToken(token) {\n\t      /* eslint no-param-reassign: 0 */\n\t      if (statement.endStatement) {\n\t        throw new Error('This statement has already got to the end.');\n\t      }\n\t\n\t      if (token.type === 'semicolon') {\n\t        statement.endStatement = ';';\n\t        return;\n\t      }\n\t\n\t      if (token.type === 'whitespace') {\n\t        prevToken = token;\n\t        return;\n\t      }\n\t\n\t      if (statement.type) {\n\t        // statement has already been identified\n\t        // just wait until end of the statement\n\t        return;\n\t      }\n\t\n\t      var currentStep = steps[currentStepIndex];\n\t      if (currentStep.preCanGoToNext(token)) {\n\t        currentStepIndex++;\n\t        currentStep = steps[currentStepIndex];\n\t      }\n\t\n\t      if (!hasRequiredBefore(currentStep)) {\n\t        var requireds = currentStep.requireBefore.join(' or ');\n\t        throw new Error('Expected any of these tokens ' + requireds + ' before \"' + token.value + '\" (currentStep=' + currentStepIndex + ').');\n\t      }\n\t\n\t      if (!isValidToken(currentStep, token)) {\n\t        var expecteds = currentStep.validation.acceptTokens.map(function (accept) {\n\t          return '(type=\"' + accept.type + '\" value=\"' + accept.value + '\")';\n\t        }).join(' or ');\n\t        throw new Error('Expected any of these tokens ' + expecteds + ' instead of type=\"' + token.type + '\" value=\"' + token.value + '\" (currentStep=' + currentStepIndex + ').');\n\t      }\n\t\n\t      currentStep.add(token);\n\t\n\t      if (currentStep.postCanGoToNext(token)) {\n\t        currentStepIndex++;\n\t      }\n\t\n\t      prevToken = token;\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.scanToken = scanToken;\n\t/**\n\t * Tokenizer\n\t */\n\t\n\t/* eslint no-param-reassign: 0 */\n\tvar KEYWORDS = ['SELECT', 'INSERT', 'DELETE', 'UPDATE', 'CREATE', 'DROP', 'TABLE', 'DATABASE', 'TRUNCATE'];\n\t\n\tvar INDIVIDUALS = {\n\t  ';': 'semicolon'\n\t};\n\t\n\tfunction scanToken(state) {\n\t  var ch = read(state);\n\t\n\t  if (isWhitespace(ch)) {\n\t    return scanWhitespace(state);\n\t  }\n\t\n\t  if (isCommentInline(ch, state)) {\n\t    return scanCommentInline(state);\n\t  }\n\t\n\t  if (isCommentBlock(ch, state)) {\n\t    return scanCommentBlock(state);\n\t  }\n\t\n\t  if (isString(ch, state)) {\n\t    return scanString(state);\n\t  }\n\t\n\t  if (isLetter(ch)) {\n\t    return scanWord(state);\n\t  }\n\t\n\t  var individual = scanIndividualCharacter(state);\n\t  if (individual) {\n\t    return individual;\n\t  }\n\t\n\t  return skipChar(state);\n\t}\n\t\n\tfunction read(state) {\n\t  if (state.position === state.input.length - 1) {\n\t    return null;\n\t  }\n\t\n\t  state.position++;\n\t  return state.input[state.position];\n\t}\n\t\n\tfunction unread(state) {\n\t  if (state.position === state.start) {\n\t    return;\n\t  }\n\t\n\t  state.position--;\n\t}\n\t\n\tfunction isKeyword(word) {\n\t  return ~KEYWORDS.indexOf(word.toUpperCase());\n\t}\n\t\n\tfunction resolveIndividualTokenType(ch) {\n\t  return INDIVIDUALS[ch];\n\t}\n\t\n\tfunction scanWhitespace(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (isWhitespace(nextChar));\n\t\n\t  if (nextChar !== null && !isWhitespace(nextChar)) {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'whitespace',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanCommentInline(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (nextChar !== '\\n' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '\\n') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'comment-inline',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanString(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (nextChar !== '\\'' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '\\'') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'string',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanCommentBlock(state) {\n\t  var nextChar = void 0;\n\t  var prevChar = void 0;\n\t\n\t  do {\n\t    prevChar = nextChar;\n\t    nextChar = read(state);\n\t  } while (prevChar + nextChar !== '*/' && nextChar !== null);\n\t\n\t  if (nextChar !== null && nextChar !== '/') {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  return {\n\t    type: 'comment-block',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanWord(state) {\n\t  var nextChar = void 0;\n\t\n\t  do {\n\t    nextChar = read(state);\n\t  } while (isLetter(nextChar));\n\t\n\t  if (nextChar !== null && !isLetter(nextChar)) {\n\t    unread(state);\n\t  }\n\t\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  if (!isKeyword(value)) {\n\t    return skipWord(state, value);\n\t  }\n\t\n\t  return {\n\t    type: 'keyword',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction scanIndividualCharacter(state) {\n\t  var value = state.input.slice(state.start, state.position + 1);\n\t  var type = resolveIndividualTokenType(value);\n\t  if (!type) {\n\t    return null;\n\t  }\n\t\n\t  return {\n\t    type: type,\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction skipChar(state) {\n\t  return {\n\t    type: 'unkown',\n\t    value: state.input.slice(state.start, state.position + 1),\n\t    start: state.start,\n\t    end: state.start\n\t  };\n\t}\n\t\n\tfunction skipWord(state, value) {\n\t  return {\n\t    type: 'unkown',\n\t    value: value,\n\t    start: state.start,\n\t    end: state.start + value.length - 1\n\t  };\n\t}\n\t\n\tfunction isWhitespace(ch) {\n\t  return ch === ' ' || ch === '\\t' || ch === '\\n';\n\t}\n\t\n\tfunction isString(ch) {\n\t  return ch === '\\'';\n\t}\n\t\n\tfunction isCommentInline(ch, state) {\n\t  var isComment = ch === '-';\n\t  if (!isComment) {\n\t    return false;\n\t  }\n\t\n\t  // lookahead\n\t  var nextChar = read(state);\n\t  isComment = nextChar === '-';\n\t  if (!isComment) {\n\t    unread(state);\n\t  }\n\t\n\t  return isComment;\n\t}\n\t\n\tfunction isCommentBlock(ch, state) {\n\t  var isComment = ch === '/';\n\t  if (!isComment) {\n\t    return false;\n\t  }\n\t\n\t  // lookahead\n\t  var nextChar = read(state);\n\t  isComment = nextChar === '*';\n\t  if (!isComment) {\n\t    unread(state);\n\t  }\n\t\n\t  return isComment;\n\t}\n\t\n\tfunction isLetter(ch) {\n\t  return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// SQLQueryIdentifier.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b884d0a5cf31df5c1d3d","import { parse } from './parser';\n\n\n/**\n * Identifier\n */\nexport function identify (query) {\n  const result = parse(query);\n\n  return result.body.map(statement => ({\n    start: statement.start,\n    end: statement.end,\n    text: query.substring(statement.start, statement.end + 1),\n    type: statement.type,\n  }));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { scanToken } from './tokenizer';\n\n\n/**\n * Parser\n */\nexport function parse (input) {\n  const topLevelState = initState({ input });\n  const topLevelStatement = {\n    type: 'QUERY',\n    start: 0,\n    end: input.length - 1,\n    body: [],\n    tokens: [],\n  };\n\n  let prevState = topLevelState;\n  let statementParser;\n\n  while (prevState.position < topLevelState.end) {\n    const tokenState = initState({ prevState });\n    const token = scanToken(tokenState);\n\n    if (!statementParser) {\n      // ignore white spaces between statements\n      if (token.type === 'whitespace') {\n        topLevelStatement.tokens.push(token);\n        prevState = tokenState;\n        continue;\n      }\n\n      statementParser = createStatementParserByToken(token);\n    }\n\n    statementParser.addToken(token);\n    topLevelStatement.tokens.push(token);\n    prevState = tokenState;\n\n    const statement = statementParser.getStatement();\n    if (statement.endStatement) {\n      statement.end = token.end;\n      topLevelStatement.body.push(statement);\n      statementParser = null;\n    }\n  }\n\n  // last statement without ending key\n  if (statementParser) {\n    const statement = statementParser.getStatement();\n    if (!statement.endStatement) {\n      statement.end = topLevelStatement.end;\n      topLevelStatement.body.push(statement);\n    }\n  }\n\n  return topLevelStatement;\n}\n\n\nfunction initState ({ input, prevState }) {\n  if (prevState) {\n    return {\n      input: prevState.input,\n      position: prevState.position,\n      start: prevState.position + 1,\n      end: prevState.input.length - 1,\n      body: [],\n    };\n  }\n\n  return {\n    input,\n    position: -1,\n    start: 0,\n    end: input.length - 1,\n    body: [],\n  };\n}\n\n\nfunction createStatementParserByToken (token) {\n  if (token.type === 'keyword') {\n    switch (token.value.toUpperCase()) {\n      case 'SELECT': return createSelectStatementParser();\n      case 'CREATE': return createCreateStatementParser();\n      case 'DROP': return createDropStatementParser();\n      case 'INSERT': return createInsertStatementParser();\n      case 'UPDATE': return createUpdateStatementParser();\n      case 'DELETE': return createDeleteStatementParser();\n      case 'TRUNCATE': return createTruncateStatementParser();\n      default: break;\n    }\n  }\n\n  throw new Error(`Invalid statement parser \"${token.value}\"`);\n}\n\n\nfunction createSelectStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Select\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'SELECT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'SELECT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createInsertStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Insert\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'INSERT' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'INSERT';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createUpdateStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Update\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'UPDATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'UPDATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createDeleteStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Delete\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DELETE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'DELETE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createCreateStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Create\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'CREATE' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `CREATE_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createDropStatementParser () {\n  const statement = {};\n\n  const steps = [\n    // Drop\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'DROP' },\n        ],\n      },\n      add: (token) => {\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n    // Table/Database\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        requireBefore: ['whitespace'],\n        acceptTokens: [\n          { type: 'keyword', value: 'TABLE' },\n          { type: 'keyword', value: 'DATABASE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = `DROP_${token.value.toUpperCase()}`;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction createTruncateStatementParser () {\n  const statement = {};\n\n  const steps = [\n    {\n      preCanGoToNext: () => false,\n      validation: {\n        acceptTokens: [\n          { type: 'keyword', value: 'TRUNCATE' },\n        ],\n      },\n      add: (token) => {\n        statement.type = 'TRUNCATE';\n        statement.start = token.start;\n      },\n      postCanGoToNext: () => true,\n    },\n  ];\n\n  return stateMachineStatementParser(statement, steps);\n}\n\n\nfunction stateMachineStatementParser (statement, steps) {\n  let currentStepIndex = 0;\n  let prevToken;\n\n  /* eslint arrow-body-style: 0, no-extra-parens: 0 */\n  const isValidToken = (step, token) => {\n    return step\n      .validation\n      .acceptTokens.filter(accept => {\n        const isValidType = token.type === accept.type;\n        const isValidValue = (\n          !accept.value\n          || token.value.toUpperCase() === accept.value\n        );\n\n        return isValidType && isValidValue;\n      }).length > 0;\n  };\n\n  const hasRequiredBefore = (step) => {\n    return (\n      !step.requireBefore\n      || ~step.requireBefore.indexOf(prevToken.type)\n    );\n  };\n\n  return {\n    getStatement () {\n      return statement;\n    },\n\n    addToken (token) {\n      /* eslint no-param-reassign: 0 */\n      if (statement.endStatement) {\n        throw new Error('This statement has already got to the end.');\n      }\n\n      if (token.type === 'semicolon') {\n        statement.endStatement = ';';\n        return;\n      }\n\n      if (token.type === 'whitespace') {\n        prevToken = token;\n        return;\n      }\n\n      if (statement.type) {\n        // statement has already been identified\n        // just wait until end of the statement\n        return;\n      }\n\n      let currentStep = steps[currentStepIndex];\n      if (currentStep.preCanGoToNext(token)) {\n        currentStepIndex++;\n        currentStep = steps[currentStepIndex];\n      }\n\n      if (!hasRequiredBefore(currentStep)) {\n        const requireds = currentStep.requireBefore.join(' or ');\n        throw new Error(`Expected any of these tokens ${requireds} before \"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      if (!isValidToken(currentStep, token)) {\n        const expecteds = currentStep\n          .validation\n          .acceptTokens\n          .map(accept => `(type=\"${accept.type}\" value=\"${accept.value}\")`)\n          .join(' or ');\n        throw new Error(`Expected any of these tokens ${expecteds} instead of type=\"${token.type}\" value=\"${token.value}\" (currentStep=${currentStepIndex}).`);\n      }\n\n      currentStep.add(token);\n\n      if (currentStep.postCanGoToNext(token)) {\n        currentStepIndex++;\n      }\n\n      prevToken = token;\n    },\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","/**\n * Tokenizer\n */\n\n/* eslint no-param-reassign: 0 */\nconst KEYWORDS = [\n  'SELECT',\n  'INSERT',\n  'DELETE',\n  'UPDATE',\n  'CREATE',\n  'DROP',\n  'TABLE',\n  'DATABASE',\n  'TRUNCATE',\n];\n\n\nconst INDIVIDUALS = {\n  ';': 'semicolon',\n};\n\n\nexport function scanToken (state) {\n  const ch = read(state);\n\n  if (isWhitespace(ch)) {\n    return scanWhitespace(state);\n  }\n\n  if (isCommentInline(ch, state)) {\n    return scanCommentInline(state);\n  }\n\n  if (isCommentBlock(ch, state)) {\n    return scanCommentBlock(state);\n  }\n\n  if (isString(ch, state)) {\n    return scanString(state);\n  }\n\n  if (isLetter(ch)) {\n    return scanWord(state);\n  }\n\n  const individual = scanIndividualCharacter(state);\n  if (individual) {\n    return individual;\n  }\n\n  return skipChar(state);\n}\n\n\nfunction read (state) {\n  if (state.position === state.input.length - 1) {\n    return null;\n  }\n\n  state.position++;\n  return state.input[state.position];\n}\n\nfunction unread (state) {\n  if (state.position === state.start) {\n    return;\n  }\n\n  state.position--;\n}\n\n\nfunction isKeyword (word) {\n  return ~KEYWORDS.indexOf(word.toUpperCase());\n}\n\n\nfunction resolveIndividualTokenType (ch) {\n  return INDIVIDUALS[ch];\n}\n\n\nfunction scanWhitespace (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isWhitespace(nextChar));\n\n  if (nextChar !== null && !isWhitespace(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'whitespace',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanCommentInline (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\n' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\n') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-inline',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanString (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (nextChar !== '\\'' && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '\\'') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'string',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanCommentBlock (state) {\n  let nextChar;\n  let prevChar;\n\n  do {\n    prevChar = nextChar;\n    nextChar = read(state);\n  } while ((prevChar + nextChar !== '*/') && nextChar !== null);\n\n  if (nextChar !== null && nextChar !== '/') {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  return {\n    type: 'comment-block',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanWord (state) {\n  let nextChar;\n\n  do {\n    nextChar = read(state);\n  } while (isLetter(nextChar));\n\n  if (nextChar !== null && !isLetter(nextChar)) {\n    unread(state);\n  }\n\n  const value = state.input.slice(state.start, state.position + 1);\n  if (!isKeyword(value)) {\n    return skipWord(state, value);\n  }\n\n  return {\n    type: 'keyword',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction scanIndividualCharacter (state) {\n  const value = state.input.slice(state.start, state.position + 1);\n  const type = resolveIndividualTokenType(value);\n  if (!type) {\n    return null;\n  }\n\n  return {\n    type,\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\nfunction skipChar (state) {\n  return {\n    type: 'unkown',\n    value: state.input.slice(state.start, state.position + 1),\n    start: state.start,\n    end: state.start,\n  };\n}\n\n\nfunction skipWord (state, value) {\n  return {\n    type: 'unkown',\n    value,\n    start: state.start,\n    end: state.start + value.length - 1,\n  };\n}\n\n\nfunction isWhitespace (ch) {\n  return ch === ' ' || ch === '\\t' || ch === '\\n';\n}\n\nfunction isString (ch) {\n  return ch === '\\'';\n}\n\n\nfunction isCommentInline (ch, state) {\n  let isComment = ch === '-';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '-';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\n\nfunction isCommentBlock (ch, state) {\n  let isComment = ch === '/';\n  if (!isComment) {\n    return false;\n  }\n\n  // lookahead\n  const nextChar = read(state);\n  isComment = nextChar === '*';\n  if (!isComment) {\n    unread(state);\n  }\n\n  return isComment;\n}\n\n\nfunction isLetter (ch) {\n  return (ch >= 'a' && ch <= 'z')\n      || (ch >= 'A' && ch <= 'Z');\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js"],"sourceRoot":""}